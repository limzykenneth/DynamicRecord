

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Source: DynamicSchema.js | Dynamic Record</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/tui-doc.css">

    
</head>
<body>
<nav class="lnb" id="lnb">
    <div class="logo" style="width: 0px; height: 0px">
        
            <img src="img/toast-ui.png" width="100%" height="100%">
        
    </div>
    <div class="title">
        <h1><a href="index.html" class="link">Dynamic Record</a></h1>
        
            <span class="version">v0.4.1</span>
        
    </div>
    <div class="search-container" id="search-container">
        <input type="text" placeholder="Search">
        <ul></ul>
    </div>
    
    <div class="lnb-api hidden"><h3>Classes</h3><ul><li><a href="DynamicCollection.html">DynamicCollection</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="DynamicCollection_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="DynamicCollection.html#data">data</a></li></ul><div class="member-type">Methods</div><ul class="inner"><li><a href="DynamicCollection.html#saveAll">saveAll</a></li></ul></div></li><li><a href="DynamicRecord.html">DynamicRecord</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="DynamicRecord_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="DynamicRecord.html#all">all</a></li><li><a href="DynamicRecord.html#closeConnection">closeConnection</a></li><li><a href="DynamicRecord.html#findBy">findBy</a></li><li><a href="DynamicRecord.html#first">first</a></li><li><a href="DynamicRecord.html#where">where</a></li></ul></div></li><li><a href="DynamicRecord.Model.html">DynamicRecord.Model</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="DynamicRecord.Model_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="DynamicRecord.Model.html#data">data</a></li></ul><div class="member-type">Methods</div><ul class="inner"><li><a href="DynamicRecord.Model.html#destroy">destroy</a></li><li><a href="DynamicRecord.Model.html#save">save</a></li><li><a href="DynamicRecord.Model.html#validate">validate</a></li></ul></div></li><li><a href="DynamicSchema.html">DynamicSchema</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="DynamicSchema_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="DynamicSchema.html#definition">definition</a></li><li><a href="DynamicSchema.html#tableName">tableName</a></li><li><a href="DynamicSchema.html#tableSlug">tableSlug</a></li></ul><div class="member-type">Methods</div><ul class="inner"><li><a href="DynamicSchema.html#addColumn">addColumn</a></li><li><a href="DynamicSchema.html#addColumns">addColumns</a></li><li><a href="DynamicSchema.html#addIndex">addIndex</a></li><li><a href="DynamicSchema.html#changeColumnType">changeColumnType</a></li><li><a href="DynamicSchema.html#createTable">createTable</a></li><li><a href="DynamicSchema.html#define">define</a></li><li><a href="DynamicSchema.html#dropTable">dropTable</a></li><li><a href="DynamicSchema.html#read">read</a></li><li><a href="DynamicSchema.html#removeColumn">removeColumn</a></li><li><a href="DynamicSchema.html#removeIndex">removeIndex</a></li><li><a href="DynamicSchema.html#renameColumn">renameColumn</a></li><li><a href="DynamicSchema.html#renameTable">renameTable</a></li></ul></div></li></ul></div>
</nav>
<div id="resizer"></div>

<div class="main" id="main">
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("dotenv").config();
const Promise = require("bluebird");
const _ = require("lodash");
let connect;
const schemaValidator = new (require("./schemaValidation.js"))(connect);
// Let's get mongodb working first
/**
 * Create an new DynamicSchema instance
 *
 * @name DynamicSchema
 * @class
 */
class Schema {
    constructor() {
        /**
         * The name of the table.
         *
         * @name tableName
         * @type string
         * @memberOf DynamicSchema
         * @instance
         */
        this.tableName = null;
        /**
         * The slug of the table.
         *
         * @name tableSlug
         * @type string
         * @memberOf DynamicSchema
         * @instance
         */
        this.tableSlug = null;
        /**
         * The table's column definitions.
         *
         * @name definition
         * @type object
         * @memberOf DynamicSchema
         * @instance
         */
        this.definition = {};
        // Async setup, should be moved to a one time setup script
        // connect.then((db) => {
        // 	return db.collection("_schema").indexExists("_$id").then((result) => {
        // 		if(!result){
        // 			return Promise.resolve(db);
        // 		}
        // 	});
        // }).then((db) => {
        // 	return db.collection("_schema").createIndex("_$id", {
        // 		unique: true
        // 	});
        // });
    }
    /**
     * Create a new table with the given schema. Schema must adhere to the
     * JSON Schema definition set out in
     * [https://json-schema.org/](https://json-schema.org/)
     *
     * Each property corresponds to each column in the database. A few
     * custom attributes to each property can be included for use by
     * DynamicSchema to generate columns for special behaviour.
     *
     * These properties are:
     * - `isIndex`: Whether the column is an index field
     * - `isUnique`: Whether the column is an unique field
     * - `isAutoIncrement`: Whether the column is an auto-incrementing integer
     *
     * @method createTable
     * @memberOf DynamicSchema
     * @instance
     * @param {object} schema
     * @param {string} schema.$id - ID of the table, must be unique
     * @param {string} [schema.title] - Defaults to `schema.$id`
     * @param {object} schema.properties - The column definitions of the table
     * @return {Promise}
     */
    createTable(schema) {
        if (!schemaValidator.validate("rootSchema", schema)) {
            return Promise.reject(schemaValidator.errors);
        }
        const tableSlug = schema.$id;
        const tableName = schema.title || schema.$id;
        const columns = schema.properties;
        return connect.then((db) => {
            const promises = [];
            // NOTE: Do we need to check for existence first?
            promises.push(db.createCollection(tableSlug).then((col) => {
                this.tableName = tableName;
                this.tableSlug = tableSlug;
                return Promise.resolve(db);
            }));
            promises.push(db.createCollection("_counters").then((col) => {
                return col.indexExists("_$id").then((result) => {
                    if (result === false) {
                        return col.createIndex("_$id", { unique: true }).then(() => {
                            return Promise.resolve();
                        });
                    }
                    else {
                        return Promise.resolve();
                    }
                }).then(() => {
                    return col.insertOne({
                        _$id: tableSlug,
                        sequences: {}
                    }).then(() => {
                        return Promise.resolve(db);
                    });
                });
            }));
            const databaseInsert = {
                _$schema: schema.$schema,
                _$id: schema.$id,
                title: schema.title,
                description: schema.description,
                type: schema.type,
                properties: schema.properties,
                required: schema.required
            };
            promises.push(db.collection("_schema").insertOne(databaseInsert));
            this.definition = columns;
            promises.push(this._writeSchema());
            return Promise.all(promises);
        }).then(() => {
            // Handle index columns
            let promises = [];
            _.each(columns, (column, key) => {
                if (column.isIndex) {
                    promises.push(this.addIndex({
                        name: key,
                        unique: column.isUnique,
                        autoIncrement: column.isAutoIncrement
                    }));
                }
            });
            return Promise.all(promises);
        }).catch((err) => {
            this.tableName = null;
            this.tableSlug = null;
            throw Promise.reject(err);
        });
    }
    /**
     * Drop the table from the database.
     *
     * @method dropTable
     * @memberOf DynamicSchema
     * @instance
     * @return {Promise}
     */
    dropTable() {
        return connect.then((db) => {
            return db.collection("_schema").deleteOne({ "_$id": this.tableSlug }).then((result) => {
                return db.collection(this.tableSlug).drop();
            }).then(() => {
                return db.collection("_counters").deleteOne({ "_$id": this.tableSlug });
            }).then(() => {
                this.tableName = null;
                this.tableSlug = null;
                this.definition = {};
                return Promise.resolve();
            });
        }).catch((err) => {
            return Promise.reject(err);
        });
    }
    /**
     * Add an index to the table's schema.
     *
     * @method renameTable
     * @memberOf DynamicSchema
     * @instance
     * @param {string} newSlug
     * @param {string} [newName] Defaults to newSlug
     * @return {Promise}
     */
    renameTable(newSlug, newName) {
        return connect.then((db) => {
            const promises = [];
            promises.push(db.collection("_schema").findOneAndUpdate({ "_$id": this.tableSlug }, {
                $set: {
                    "_$id": newSlug,
                    "title": newName || newSlug
                }
            }));
            promises.push(db.collection("_counters").findOneAndUpdate({ "_$id": this.tableSlug }, {
                $set: {
                    "_$id": newSlug
                }
            }));
            promises.push(db.renameCollection(this.tableSlug, newSlug));
            return Promise.all(promises);
        }).then(() => {
            this.tableSlug = newSlug;
            this.tableName = newName || newSlug;
            return Promise.resolve();
        });
    }
    /**
     * Add an index to the table's schema.
     *
     * @method addIndex
     * @memberOf DynamicSchema
     * @instance
     * @param {object} options
     * @param {string} options.name - The name of the column to be used as index
     * @param {boolean} [options.unique] - Whether the index is unique or not
     * @param {boolean} [options.autoInrement] - Whether it is an
     *                  auto-incrementing index or not. If true, `options.unique`
     *                  is automatically set to true
     * @return {Promise}
     */
    addIndex(options) {
        const columnName = options.name;
        const isAutoIncrement = options.autoIncrement;
        let unique = options.unique;
        if (isAutoIncrement &amp;&amp; unique === false) {
            console.warn("Auto increment index must be unique, setting to unique.");
            unique = true;
        }
        if (typeof unique === "undefined") {
            unique = true;
        }
        return connect.then((db) => {
            return db.collection(this.tableSlug).createIndex(columnName, { unique: unique, name: columnName });
        }).then(() => {
            if (isAutoIncrement) {
                return this._setCounter(this.tableSlug, columnName);
            }
            else {
                return Promise.resolve();
            }
        }).catch((err) => {
            throw err;
        });
    }
    renameIndex(columnName, newColumnName) {
        // Maybe drop index then recreate but do consider why you need to do this
    }
    /**
     * Remove an index to the table's schema
     *
     * @method removeIndex
     * @memberOf DynamicSchema
     * @instance
     * @param {string} columnName - The name of the index to remove
     * @return {Promise}
     */
    removeIndex(columnName) {
        return connect.then((db) => {
            return db.collection(this.tableSlug).dropIndex(columnName)
                .then(() => {
                return Promise.resolve(db);
            });
        }).then((db) => {
            if (columnName === "_uid") {
                return db.collection("_counters").findOneAndDelete({
                    _$id: this.tableSlug
                });
            }
            else {
                return Promise.resolve();
            }
        }).catch((err) => {
            throw err;
        });
    }
    /**
     * Read the schema definition from the database.
     *
     * @method read
     * @memberOf DynamicSchema
     * @instance
     * @param {string} tableSlug - The name of the table schema to retrieve
     * @return {Promise} - Return promise, resolves to this object instance
     */
    read(tableSlug) {
        return connect.then((db) => {
            return db.collection("_schema").findOne({ _$id: tableSlug });
        }).then((data) => {
            if (data) {
                this.tableName = data.title;
                this.tableSlug = data._$id;
                this.definition = data.properties;
            }
            else {
                this.tableName = "";
                this.tableSlug = "";
                this.definition = {};
            }
            return Promise.resolve(this);
        }).catch((err) => {
            throw err;
        });
    }
    /**
     * Define the table's columns. Passed object must adhere to `properties`
     * attribute of [JSON Schema](https://json-schema.org/)'s definition.
     *
     * @method define
     * @memberOf DynamicSchema
     * @instance
     * @param {object} definition - Definition of the table columns
     * @return {Promise}
     */
    define(def) {
        const oldDef = this.definition;
        this.definition = def;
        // Create schema in RMDB, do nothing in NoSQL
        return connect.then((db) => {
            return db.collection("_schema").findOneAndUpdate({
                _$id: this.tableSlug,
            }, {
                $set: {
                    properties: def
                }
            }, {
                upsert: true
            });
        }).catch((err) => {
            this.definition = oldDef;
            throw err;
        });
    }
    /**
     * Add a single column to the table's schema definition.
     *
     * @method addColumn
     * @memberOf DynamicSchema
     * @instance
     * @param {string} name - The name of the column to add
     * @param {string} type - Type of the column to add
     * @param {string} [description] - Description of the column to add
     * @return {Promise}
     */
    addColumn(name, type, description = "") {
        if (!this.definition[name]) {
            this.definition[name] = {
                description: description,
                type: type
            };
        }
        else {
            // Column name already exist
            throw new Error("Column name already exist");
        }
        return this._writeSchema().catch((err) => {
            delete this.definition[name];
            throw err;
        });
    }
    /**
     * Add multiple columns to the table's schema definition.
     *
     * @method addColumns
     * @memberOf DynamicSchema
     * @instance
     * @param {object} definitions - Object of objects containing new columns
     *                               definitions
     * @return {Promise}
     */
    addColumns(def) {
        const oldDefinition = _.cloneDeep(this.definition);
        this.definition = _.assign(this.definition, def);
        return this._writeSchema().catch((err) => {
            this.definition = _.cloneDeep(oldDefinition);
            throw err;
        });
    }
    /**
     * Rename a single column in the table's schema definition.
     *
     * @method renameColumn
     * @memberOf DynamicSchema
     * @instance
     * @param {string} name - The name of the column to rename
     * @param {string} newName - The new name of the target column
     * @return {Promise}
     */
    renameColumn(name, newName) {
        this.definition[newName] = _.cloneDeep(this.definition[name]);
        delete this.definition[name];
        return connect.then((db) => {
            return this._writeSchema().then(() => {
                return db.collection("_counters").findOne({ "_$id": this.tableSlug });
            }).then((entry) => {
                if (entry) {
                    const sequences = _.cloneDeep(entry.sequences);
                    sequences[newName] = sequences[name];
                    delete sequences[name];
                    return db.collection("_counters").findOneAndUpdate({ "_$id": this.tableSlug }, {
                        $set: {
                            sequences: sequences
                        }
                    });
                }
                else {
                    return Promise.resolve();
                }
            }).catch((err) => {
                this.definition[name] = _.cloneDeep(this.definition[newName]);
                delete this.definition[newName];
                throw err;
            });
        });
    }
    /**
     * Change the type of a single column in the table's schema definition.
     *
     * @method changeColumnType
     * @memberOf DynamicSchema
     * @instance
     * @param {string} name - The name of the column to change type
     * @param {string} newType - The new type of the target column
     * @return {Promise}
     */
    changeColumnType(name, newType) {
        const oldType = this.definition[name].type;
        this.definition[name].type = newType;
        return this._writeSchema().catch((err) => {
            this.definition[name].type = oldType;
            throw err;
        });
    }
    /**
     * Remove a single column from the table's schema definition.
     *
     * @method removeColumn
     * @memberOf DynamicSchema
     * @instance
     * @param {string} name - The name of the column to remove
     * @return {Promise}
     */
    removeColumn(name) {
        const deleted = _.cloneDeep(this.definition[name]);
        delete this.definition[name];
        return this._writeSchema().catch((err) => {
            this.definition[name] = deleted;
            throw err;
        });
    }
    // Utils --------------------------------------------------------
    /**
     * Update the new schema structure into the database
     *
     * @method _writeSchema
     * @memberOf DynamicSchema
     * @instance
     * @private
     * @return {Promise}
     */
    _writeSchema() {
        return connect.then((db) => {
            return db.collection("_schema").findOneAndUpdate({ _$id: this.tableSlug }, {
                $set: {
                    properties: this.definition
                }
            });
        });
    }
    /**
     * Set an autoincrementing field to the _counters table (MongoDB only)
     *
     * @method _setCounter
     * @memberOf DynamicSchema
     * @instance
     * @private
     * @param {string} collection - The slug of the collection to set
     * @param {string} columnLabel - The slug of the column set as an autoincrementing index
     * @return {Promise}
     */
    _setCounter(collection, columnLabel) {
        return connect.then((db) => {
            const sequenceKey = `sequences.${columnLabel}`;
            return db.collection("_counters").findOneAndUpdate({
                _$id: collection
            }, {
                $set: {
                    [sequenceKey]: 0
                }
            });
        });
    }
    /**
     * Increment an autoincrementing index (MongoDB only)
     *
     * @method _setCounter
     * @memberOf DynamicSchema
     * @instance
     * @private
     * @param {string} collection - The slug of the collection to target
     * @param {string} columnLabel - The slug of the autoincrementing column
     * to increment
     * @return {Promise} - Promise of the next number in the sequence
     */
    _incrementCounter(collection, columnLabel) {
        return connect.then((db) => {
            return db.collection("_counters").findOne({
                _$id: collection
            }).then((result) => {
                const newSequence = result.sequences[columnLabel] + 1;
                const sequenceKey = `sequences.${columnLabel}`;
                return db.collection("_counters").findOneAndUpdate({
                    _$id: collection
                }, {
                    $set: {
                        [sequenceKey]: newSequence
                    }
                }).then(() => {
                    return Promise.resolve(newSequence);
                });
            });
        });
    }
    _validate() {
        // Validate database schema with this.definition
        // Return boolean
    }
}
module.exports = function (connection) {
    connect = connection;
    return Schema;
};
</code></pre>
        </article>
    </section>




</div>

<footer>
    <img class="logo" src="img/toast-ui.png" style="width: 0px; height: 0px">
    <div class="footer-text">Dynamic Record by Kenneth Lim</div>
</footer>
<script>prettyPrint();</script>
<script src="scripts/jquery.min.js"></script>
<script src="scripts/tui-doc.js"></script>
<script src="scripts/linenumber.js"></script>

    <script>
        var id = '_sub'.replace(/"/g, '_');
        var selectedApi = document.getElementById(id); // do not use jquery selector
        var $selectedApi = $(selectedApi);

        $selectedApi.removeClass('hidden');
        $selectedApi.parent().find('.glyphicon').removeClass('glyphicon-plus').addClass('glyphicon-minus');
        showLnbApi();
    </script>

</body>
</html>
